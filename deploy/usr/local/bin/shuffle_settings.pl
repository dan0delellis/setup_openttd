#!/usr/bin/perl
use strict;
use warnings;
use SetupOpenTTD::Shortcuts qw(do_cmd do_cmd_topline);
use MIME::Base64;
use Data::Dumper;
use Getopt::Long;

my @protected = qw(version_string version_number ini_version);

my $opts;

my $defaults;
#The config file should be in ~/custom for the user executing the script
my $home        = $ENV{HOME};
my $custom      = "$home/custom";
my $opts_file   = "$home/custom_options.cfg";
my $template    = "$home/.config/openttd/openttd.cfg";
my $target_file = "$custom/openttd.cfg.shuffled";

GetOptions (
    "s|settings-file=s"     =>  \$opts_file,
    "t|template-config=s"   =>  \$template,
    "d|defaults!"           =>  \$defaults,
    "f|target-file=s"       =>  \$target_file,
);

#If called with --defaults, don't read the customs file. just print out the contents of the default config
unless ($defaults) {
    open (my $ro, "<", $opts_file) or die "Unable to open settings file '$opts_file'. Can't generate the config:$!\n";
    $opts = process_custom($ro);
    close ($ro);
}

#Read a base config file, hopefully generated by openttd
open(my $ro, "<", $template) or die "Failed to load default config file '$template': $!\n";

my $conf = generate_conf($ro,$opts);
close($ro);

#Spew the contents of the generated config into the target file
open(my $fh, ">", $target_file) or die "Failed to create custom settings file '$target_file':$!\n";
print $fh $conf;
close($fh);

#subfunctions
sub process_custom {
    my ($ro) = @_;
    my $dat;
    while (my $line=<$ro>) {
        my ($opt,$setting) = scan_line($line);
        if (defined $opt && defined $setting) {
            $dat->{$opt} = $setting;
        }
    }
    return $dat;
}

sub generate_conf {
    my ($ro,$cfg) = @_;
    my @out;

    while (my $line=<$ro>) {
        my ($k,$v) = scan_line($line);

        #Keep empty lines
        unless (defined $k && $k !~ m/^\s*$/) {
            push @out, " ";
            next;
        }

        #keep section headers
        if ($k =~m/^\[(\S)+\]$/) {
            push @out, $k;
            next
        }

        #keep lines with no option set
        unless (defined $v) {
            push @out, "$k = ";
            next;
        }

        #If a custom option was configured, override the default
        if (exists $cfg->{$k} && defined $cfg->{$k}) {
            $v = $cfg->{$k};
        }

        $line = "$k = $v";
        push @out, $line;
    }
    my $data = join("\n",@out);
    return $data;
}

sub scan_line {
    my ($li) = @_;
    if ($li =~ m/(^#|^$)/) {
        return ($li);
    }
    my $val;
    chomp $li;
    if ($li =~ m/;/) {
        my @parts = split(/;/, $li);
        $li = shift @parts;
    }
    my @kv = split(/\s*=\s*/, $li);


    my $k = shift @kv;
    #AI lines look like `none = start_date=730` and are not yet supported

    if (scalar @kv > 1) {
        $val = process_ai(@kv);
        return ($k,$val);
    }

    my $v = shift @kv;
    unless (defined $v) {
        return ($k);
    }


    if ($v =~ m/^\s*<\s*(\S+)\s*>\s*$/) {
        $val = process_random($1);
    } else {
        $val = $v;
    }

    return ($k,$val);
}

sub process_ai {
    #I'm not entirely sure how to set these yet
    my @parts = @_;
    my $v = join("=",@parts);
    return $v;
}

sub process_random {
    my ($l) = @_;
    my @arr;

    #handle booleans
    if ($l =~ m/^bool(ean)?$/i) {
        $l = "true,false";
    }

    #evaluate number range
    if ($l =~ m/([0-9]+)\.\.([0-9]+)/) {
        @arr = ($1 .. $2);
    }

    #evaluate lists
    if ($l =~ m/^[a-zA-Z0-9,]+$/) {
        @arr = split(/,/, $l);
    }

    return $arr[int rand (@arr)];
}
