#!/usr/bin/perl
use strict;
use warnings;
use SetupOpenTTD::Shortcuts qw(do_cmd do_cmd_topline do_cmd_silent contains);
use MIME::Base64;
use Data::Dumper;
use Getopt::Long;
use List::Util qw(uniq);

my @protected = qw(version_string version_number ini_version);
my $meta_key = 'shuffler^constraints';
my ($k_value,$k_sum,$k_range,$k_keypair,$k_wanted,$k_possible,$k_available) = qw(value sum range keypair want possible available);
my $debug;

#Hashref containing data structure of the form
# keyN => ('val' => x, 'range' => (a..b)), where
#  keyN is some option from the config,
#  the range is the user-defined range,
#  and x is the setting randomly selected from that range
#Constraint options will get stored in a subhash 'shuffler^constraints'

#k->v store of all options set in the configs
my $opts;

#k-@v store of grf config options set in grf custom config
my $grf_opts;

my $defaults;
#The config file should be in ~ for the user executing the script

my $home        = $ENV{HOME};

my @paths = get_paths($home);
my ($opts_file, $grf_file, $conf_path, $template, $target_file) = @paths;
my ($cli_user,$cli_opts_file, $cli_conf_path, $cli_template, $cli_target_file,$cli_defaults,$cli_grf_file);

GetOptions (
    "u|user=s"              =>  \$cli_user,
    "s|settings-file=s"     =>  \$cli_opts_file,
    "t|template-config=s"   =>  \$cli_template,
    "f|target-file=s"       =>  \$cli_target_file,
    "d|defaults!"           =>  \$cli_defaults,
    "g|grf_conf=s"          =>  \$cli_grf_file,
);

if (defined $cli_user) {
    #Update paths if you are defining the user who's home directory has the config files we want

    $home = do_cmd_topline("realpath ~$cli_user");
    @paths = get_paths($home);
    ($opts_file, $grf_file, $conf_path, $template, $target_file) = @paths;

}
#override generated paths if cli options were provided
$opts_file   = $cli_opts_file if (defined $cli_opts_file);
$grf_file    = $cli_grf_file if (defined $cli_grf_file);
$conf_path   = $cli_conf_path if (defined $cli_conf_path);
$template    = $cli_template if (defined $cli_template);
$target_file = $cli_target_file if (defined $cli_target_file);

#If called with --defaults, don't read the customs file. just print out the contents of the default config
unless ($defaults) {
    open (my $ro, "<", $opts_file) or die "Unable to open settings file '$opts_file'. Can't generate the config:$!\n";
    $opts = process_custom($ro);
    close ($ro);

    #Process constraint options
    foreach my $lim(@{$opts->{$meta_key}}) {
        process_lim($lim);
    }


    #Process GRF configs
    SET_GRF:{
        print Dumper "processing grf data" if $debug;
        open (my $gro, "<", $grf_file) or do {
            print "Unable to open grf settings file '$grf_file'. Won't set these options\n";
            last SET_GRF;
        };
        $grf_opts = process_grf($gro, $opts);
        print Dumper "Got grf options: " if $debug;
        print Dumper $grf_opts if $debug;
        close $gro;
    }

}

#Read a base config file, hopefully generated by openttd
open(my $ro, "<", $template) or die "Failed to load default config file '$template': $!\n";

my $conf = generate_conf($ro,$opts,$grf_opts);
close($ro);


#Spew the contents of the generated config into the target file
open(my $fh, ">", $target_file) or die "Failed to create custom settings file '$target_file':$!\n";
print $fh $conf;
close($fh);

if (defined $cli_user) {
    do_cmd_silent("chown $cli_user:$cli_user $target_file");
}

#subfunctions
sub get_paths {
    my ($h) = @_;
    my $of   = "$h/custom_options.cfg";
    my $gf   = "$h/grf_options.cfg";
    my $cp   = "$h/.config/openttd/";
    my $t    = "$cp/openttd.cfg.orig";
    my $tf   = "$cp/openttd.cfg";

    return ($of,$gf,$cp,$t,$tf);
}

sub process_grf {
    my ($ro, $cfg) = @_;
    my $grf;
    while (my $l=<$ro>) {
        print Dumper $l if $debug;
        next if ($l =~  m/^(\[\S+\])?$/);
        #$l: 52570103|EDB2D26F9D81423734CA12412F309CF3|generic_tram_set.0.4\generictrams.grf =

        my @parts = split(/=/, $l);
        my $k = shift @parts;
        print Dumper "grf meta: $k" if $debug;;

        next if (scalar(@parts) < 1);
        my $v = shift @parts;
        print Dumper "grf params: $v" if $debug;
        #$v: <conf.map:landscape:temperate,0,arctic,1,tropic,2> 0 0 0 0 0 16 150 80 300 1

        my @params = split(/\s/,$v);

        foreach my $p (@params) {
            #generate a hash from the values included, use value 2 as a key for $conf to get the setting to apply
            if ($p =~ m/^<conf\.map:(\S+):(\S+)>$/) {
                my $conf_key = $1;
                my $dat = $2;
                my %temp = split(/,/,$2);
                print Dumper "parsed map, conf key <$conf_key>; conditional options based on $conf_key:" if $debug;
                print Dumper \%temp  if $debug;
                my $temp_key = "[default]";

                if (exists $cfg->{$conf_key}->{value} && defined $cfg->{$conf_key}->{value}) {
                    $temp_key = $cfg->{$conf_key}->{value};
                } else {
                    print Dumper "<$conf_key> not set in generated config. Using default value" if $debug;
                }

                if (exists $temp{$temp_key} && defined $temp{$temp_key}) {
                    print Dumper "grabbing option <$temp_key> from generated conf" if $debug;
                } else {
                    print Dumper "no option set for <$temp_key>, using default value" if $debug;
                    $temp_key = "[default]";
                }
                $p = $temp{$temp_key};

                print Dumper "value gonna be <$p>" if $debug;
                next;
            }
            #for now only support variadic options, later support range, list options. probably not constraint options
        }
        $grf->{$k} = join(" ", @params);
    }
    return $grf;
}

sub process_custom {
    my ($ro) = @_;
    my $dat;
    while (my $line=<$ro>) {
        chomp $line;
        print Dumper "Read line: $line" if $debug;
        next if ($line =~ m/(^$|^#)/);
        my ($opt,$setting,$range,$meta) = scan_line($line);
        if (contains(\@protected, $opt)) {
            next;
        }
        if ($meta) {
            #We'll process the contraints after all the custom options have been generated
            push @{$dat->{$meta_key}}, $meta;
        }
        if (defined $opt && defined $setting) {
            $dat->{$opt}->{$k_value} = $setting;
            print Dumper "name: $opt, setting: $setting, range: " . oneline_list($range) if $debug;
            if (scalar @{$range} > 0) {
                $dat->{$opt}->{$k_range} = $range;
            }
        }
    }
    return $dat;
}

sub get_grf {
    my ($grf) = @_;
    my @data = qw/[newgrf]/;
    foreach my $k (keys %$grf) {
        print Dumper "adding line " if $debug;
        print Dumper $k if $debug;
        print Dumper $grf->{$k} if $debug;
        push @data, "$k = $grf->{$k}";
    }
    my $content = join("\n", @data);
    print Dumper "generated content:" if $debug;
    return $content;
}

sub generate_conf {
    #rc: config file handle;
    #$cfg: k->v store of options
    my ($rc,$cfg,$grf) = @_;
    my @out;
    my %meta;

    while (my $line=<$rc>) {
        my ($k,$v,$range,$meta) = scan_line($line);

        #Keep empty lines
        unless (defined $k && $k !~ m/^\s*$/) {
            push @out, " ";
            next;
        }

        #Skip lines that have configurations in grf_options.cfg
        if (exists $grf->{$k}) {
            next;
        }

        #keep section headers
        if ($k =~m/^\[(\S+)\]$/) {
            if ($1 =~ m/^newgrf$/) {
                print Dumper "oh boy here we go" if $debug;
                #writes a pre-formatted line "[newgrf]\nGRF_ID|GRF_MD5|GRF_FILE = PARAM_1, PARAM_2, ..., PARAM_N" as a 'key'
                $k = get_grf($grf);

                print Dumper "got: <$k>" if $debug;
            }
            push @out, $k;
            next;
        }

        #keep lines with no option set
        unless (defined $v) {
            push @out, "$k = ";
            next;
        }


        #If a custom option was configured, override the default
        if (exists $cfg->{$k} && defined $cfg->{$k}) {
            $v = $cfg->{$k}->{$k_value};
        }

        $line = "$k = $v";
        push @out, $line;
    }
    my $data = join("\n",@out);
    return $data;
}

sub scan_line {
    my ($li) = @_;
    my $val;
    my $range;
    my $meta;

    if ($li =~ m/(^#|^$)/) {
        return ($li);
    }
    chomp $li;
    if ($li =~ m/;/) {
        my @parts = split(/;/, $li);
        $li = shift @parts;
    }
    my @kv = split(/\s*=\s*/, $li);


    my $k = shift @kv;

    #AI lines look like `none = start_date=730` and are not yet supported for randomization settings
    if (scalar @kv > 1) {
        $val = process_ai(@kv);
        return ($k,$val);
    }

    my $v = shift @kv;
    unless (defined $v) {
        #$k has no option set, $v and $range are both undefined
        return ($k);
    }
    print Dumper "Processing configured setting '$v'" if $debug;
    #if it gets to this point, we actually are trying to configure an option. possibly randomized, or a static setting
    if ($v =~ m/^\s*<\s*(\S+)\s*>\s*$/) {
        my $rand = $1;
        print Dumper "Looks like someone wants some randomness $rand" if $debug;
        #randomly set option, range should be list of all possible values
        ($val,$range) = process_random($rand);
        print Dumper "Got value $val and range: " . oneline_list($range) if $debug;
    } else {
        #statically defined option, define it's range as ($v);
        $val = $v;
        push @$range, $v;
        print Dumper "Value is statically set to $v, so range is: " . oneline_list($range) if $debug;
    }

    #handle multi-option constraint lines: <shuffler.$option1+$option2> = <a..b>
    # the generated values for opt1,opt2, as well as their respective ranges, are required for validation,
    # but there's no gaurantee that those have been set yet in the custom options file.
    # So, those will have to wait until the options file is fully processed
    if ($k =~ m/^\s*<\s*shuffler\.\s*(\S+)\s*\+\s*(\S+)\s*>\s*$/i) {
        my ($opt1,$opt2) = sort ($1,$2);
        @{$meta->{$k_keypair}} = ($opt1,$opt2);
        $meta->{$k_wanted} = $range;
    }
    print Dumper "is range still set?" . oneline_list($range) if $debug;

    if (!defined $meta) {
        $meta = 0;
    }

    return ($k,$val,$range,$meta);
}

sub process_ai {
    #I'm not entirely sure how to set these yet
    my @parts = @_;
    my $v = join("=",@parts);
    return $v;
}

sub process_random {
    my ($l) = @_;
    my @arr;

    print Dumper "working on line $l" if $debug;
    #handle booleans
    if ($l =~ m/^bool(ean)?$/i) {
        print Dumper "looks like a boolean opt" if $debug;
        $l = "true,false";
    }

    #evaluate number range
    if ($l =~ m/([0-9]+)\.\.([0-9]+)/) {
        print Dumper "looks like an int range" if $debug;
        @arr = ($1 .. $2);
    }

    #evaluate lists
    if ($l =~ m/^[a-zA-Z0-9,]+$/) {
        print Dumper "looks like a descrete list" if $debug;
        @arr = split(/,/, $l);
    }

    print Dumper "my range is: "  . oneline_list(\@arr) if $debug;

    return ($arr[int rand (@arr)], \@arr);
}

sub process_lim {
    my ($h) = @_;
    print Dumper "oh boy oh boy!" if $debug;
    my ($a,$b) = @{$h->{$k_keypair}};
    my @r = @{$h->{$k_wanted}};
    print Dumper "$k_wanted: " . oneline_list(\@r) if $debug;

    #First get the ranges allowed from the config
    my @ra = @{$opts->{$a}->{$k_range}};
    my @rb = @{$opts->{$b}->{$k_range}};
    print Dumper "$a: " . oneline_list(\@ra) if $debug;
    print Dumper "$b: " . oneline_list(\@rb) if $debug;

    #Force them both to be defined
    #~later~~

    my @possible;
    foreach my $i (@ra) {
        foreach my $j (@rb) {
            push @possible, $i+$j;
        }
    }
    @possible = uniq @possible;
    print Dumper "all possible sums: " . oneline_list(\@possible) if $debug;

    $h->{$k_possible} = \@possible;
    $h->{$k_sum} = $opts->{$a}->{$k_value} + $opts->{$b}->{$k_value};
    print Dumper "got sum: $h->{$k_sum}" if $debug;

    #Find the intersection of the two
    #considered forcing one to be a subset of the other but it was a pain to decide which should be the superset

    my @avail = intersect($h->{$k_wanted},$h->{$k_possible});
    print Dumper "got intersection: " . oneline_list(\@avail) if $debug;

    #If this is an empty list, force both values to be whatever the first value in the range is for both lists
    #~later~~

    $h->{$k_available} = \@avail;
    #$succss = 0;

    #Is what got generated a desired result?
    if (i_elementof_J($h->{$k_sum},$h->{$k_available})) {
        #$succss += 1;
        return;
    }

    #If I keep my value of 'a', can I get a valid value for 'b'?
    my @rb_reduced = I_reduceby_j($h->{$k_available},$opts->{$a}->{$k_value});

    @rb_reduced = intersect(\@rb_reduced,\@rb);
    if (scalar @rb_reduced > 0) {
        $opts->{$b}->{$k_value} = $rb_reduced[rand scalar @rb_reduced];
        #$succss += 2;
        return;
    }

    #Let's do the same for a
    my @ra_reduced = I_reduceby_j($h->{$k_available},$opts->{$b}->{$k_value});
    @ra_reduced = intersect(\@ra_reduced,\@ra);
    if (scalar @ra_reduced > 0) {
        $opts->{$a}->{$k_value} = $ra_reduced[rand scalar @ra_reduced];
        #$succss += 4;
        return;
    }

    #Somehow, no value for a or b has a corresponding valid value for the other setting
    #This means we need to reshuffle, but even that has a chance of failure, if the above is true
    #We already determined that there is a valid set of available sums, so let's iterate through those
    #And then find an A/B pair that fits
    foreach my $forced_sum (@{$h->{$k_available}}) {
        foreach my $m(reverse @ra) {
            my $n = $forced_sum - $m;
            if (i_elementof_J($n,\@rb)) {
                $opts->{$a}->{$k_value} = $m;
                $opts->{$b}->{$k_value} = $n;
                #$succss += 8;
                return;
            }
        }

        foreach my $n(reverse @rb) {
            my $m = $forced_sum -$n;
            if (i_elementof_J($m,\@ra)) {
                $opts->{$a}->{$k_value} = $m;
                $opts->{$b}->{$k_value} = $n;
                #$succss += 16;
                return;
            }
        }
    }

    #Getting to this shouldn't be possible, because the list of available options is
    #Defined as the list of sum values that are possible intersected with sum values that are desired
    print "Error processing key pair constraint:" . join("+",$a,$b) . "\n";
    print "Unable to generate a pair of values that satisfy requested sum range that also satisfies individual ranges for $a and $b.\n";
    print "Defined range for $a: ". oneline_list(\@ra) . "\n";
    print "Defined rbnge for $b: ". oneline_list(\@rb) . "\n";
    print "Possible sum range: " . oneline_list(\@possible) . "\n";
    print "Requested sum range: " . oneline_list(\@r) . "\n";
    print "Intersection of possible ^ requested: " . oneline_list(\@avail) . "\n";
    print "This kind of error shouldn't be possible but the world is full of surprises\n";
    print "Keeping initially generated values for $a,$b\n";
    exit 1;
}

sub I_reduceby_j {
    my ($r,$j) = @_;
    my @I;
    foreach my $v(@{$r}) {
        push @I, ($v - $j);
    }
    return @I;
}

sub i_elementof_J {
    my ($e,$r) = @_;
    foreach my $i(@{$r}) {
        if ($e == $i) {
            return 1;
        }
    }
    return 0;
}

sub intersect {
    my ($i, $j) = @_;
    print Dumper $i if $debug;
    print Dumper $j if $debug;

    my @int;
    foreach my $ii (@{$i}) {
        foreach my $jj (@{$j}) {
            if ($ii == $jj) {
                push @int, $ii;
            }
        }
    }
    return @int;
}
sub oneline_list {
    my ($l) = @_;
    return join(",",@{$l});
}
