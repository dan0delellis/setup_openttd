#!/usr/bin/perl
use strict;
use warnings;
use SetupOpenTTD::Shortcuts qw(do_cmd do_cmd_topline contains);
use MIME::Base64;
use Data::Dumper;
use Getopt::Long;

my @protected = qw(version_string version_number ini_version);
my $meta_key = 'shuffler^constraints';

#Hashref containing data structure of the form
# keyN => ('val' => x, 'range' => (a..b)), where
#  keyN is some option from the config,
#  the range is the user-defined range,
#  and x is the setting randomly selected from that range
#Constraint options will get stored in a subhash 'shuffler^constraints'

my $opts;

my $defaults;
#The config file should be in ~ for the user executing the script

my $home        = $ENV{HOME};
my $opts_file   = "$home/custom_options.cfg";
my $conf_path   = "$home/.config/openttd/";
my $template    = "$conf_path/openttd.cfg.orig";
my $target_file = "$conf_path/openttd.cfg";

GetOptions (
    "s|settings-file=s"     =>  \$opts_file,
    "t|template-config=s"   =>  \$template,
    "d|defaults!"           =>  \$defaults,
    "f|target-file=s"       =>  \$target_file,
);

#If called with --defaults, don't read the customs file. just print out the contents of the default config
unless ($defaults) {
    open (my $ro, "<", $opts_file) or die "Unable to open settings file '$opts_file'. Can't generate the config:$!\n";
    $opts = process_custom($ro);
    close ($ro);
}

#Process constraint options
foreach my $lim(@{$opts}->{$meta_key}) {
    process_lim($lim);
}


#Read a base config file, hopefully generated by openttd
open(my $ro, "<", $template) or die "Failed to load default config file '$template': $!\n";

my $conf = generate_conf($ro,$opts);
close($ro);


#Spew the contents of the generated config into the target file
open(my $fh, ">", $target_file) or die "Failed to create custom settings file '$target_file':$!\n";
print $fh $conf;
close($fh);

#subfunctions
sub process_custom {
    my ($ro) = @_;
    my $dat;
    while (my $line=<$ro>) {
        my ($opt,$setting,$range,$meta) = scan_line($line);
        if (contains(\@protected, $opt)) {
            next;
        }
        if ($meta) {
            #We'll process the contraints after all the custom options have been generated
            push @$dat->{$meta_key}, $meta;
        }
        if (defined $opt && defined $setting) {
            $dat->{$opt}->{val} = $setting;
            if (scalar @{$range} > 0) {
                $dat->{$opt}->{range} = $range;
            }
        }
    }
    return $dat;
}

sub generate_conf {
    my ($rc,$cfg) = @_;
    my @out;
    my %meta;

    while (my $line=<$rc>) {
        my ($k,$v,$range) = scan_line($line);

        #Keep empty lines
        unless (defined $k && $k !~ m/^\s*$/) {
            push @out, " ";
            next;
        }

        #keep section headers
        if ($k =~m/^\[(\S)+\]$/) {
            push @out, $k;
            next
        }

        #keep lines with no option set
        unless (defined $v) {
            push @out, "$k = ";
            next;
        }


        #If a custom option was configured, override the default
        if (exists $cfg->{$k} && defined $cfg->{$k}) {
            $v = $cfg->{$k};
        }

        $line = "$k = $v";
        push @out, $line;
    }
    my $data = join("\n",@out);
    return $data;
}

sub scan_line {
    my ($li) = @_;
    my $range;

    if ($li =~ m/(^#|^$)/) {
        return ($li);
    }
    my $val;
    chomp $li;
    if ($li =~ m/;/) {
        my @parts = split(/;/, $li);
        $li = shift @parts;
    }
    my @kv = split(/\s*=\s*/, $li);


    my $k = shift @kv;

    #AI lines look like `none = start_date=730` and are not yet supported for randomization settings
    if (scalar @kv > 1) {
        $val = process_ai(@kv);
        return ($k,$val);
    }

    my $v = shift @kv;
    unless (defined $v) {
        #$k has no option set, $v and $range are both undefined
        return ($k);
    }

    #if it gets to this point, we actually are trying to configure an option. possibly randomized, or a static setting
    if ($v =~ m/^\s*<\s*(\S+)\s*>\s*$/) {
        #randomly set option, range should be list of all possible values
        ($val,$range) = process_random($1);
    } else {
        #statically defined option, define it's range as ($v);
        $val = $v;
        push @$range, $v;
    }

    my $meta;
    #handle multi-option constraint lines: <shuffler.$option1+$option2> = <a..b>
    # the generated values for opt1,opt2, as well as their respective ranges, are required for validation,
    # but there's no gaurantee that those have been set yet in the custom options file.
    # So, those will have to wait until the options file is fully processed
    if ($k =~ m/^\s*<\s*shuffler\.\s*(\S+)\s*\+\s*(\S+)\s*>\s*$/i) {
        my ($opt1,$opt2) = sort ($1,$2);
        $meta->{keypair} = ($opt1,$opt2);
        $meta->{desired} = $range;
    }

    return ($k,$val,$range,$meta);
}

sub process_ai {
    #I'm not entirely sure how to set these yet
    my @parts = @_;
    my $v = join("=",@parts);
    return $v;
}

sub process_random {
    my ($l) = @_;
    my @arr;

    #handle booleans
    if ($l =~ m/^bool(ean)?$/i) {
        $l = "true,false";
    }

    #evaluate number range
    if ($l =~ m/([0-9]+)\.\.([0-9]+)/) {
        @arr = ($1 .. $2);
    }

    #evaluate lists
    if ($l =~ m/^[a-zA-Z0-9,]+$/) {
        @arr = split(/,/, $l);
    }

    return ($arr[int rand (@arr)], \@arr);
}

sub process_lim {
    #this doesn't do anything yet
    my ($h) = @_;
    my ($a,$b) = @{$h->{keypair}};
    my @r = @{$h->{desired}};

    #First get the ranges allowed from the config
    my @ra = @{$opts->{$a}->{range}};
    my @rb = @{$opts->{$b}->{range}};

    #Force them both to be defined
    #~later~~

    my @possible;
    foreach my $i (@ra) {
        foreach my $j (@rb) {
            push @possible, $i+$j;
        }
    }
    @possible = uniq @possible;

    my %tmp;
    my $t = \%tmp;

    $t->{'possible'} = \@possible;
    $t->{'generated'} = $opts->{$a}->{'val'} + $opts->{$b}->{'val'};

    #Find the intersection of the two
    #considered forcing one to be a subset of the other but it was a pain to decide which should be the superset

    my @avail = intersect($t->{want},$t->{possible});

    #If this is an empty list, force both values to be whatever the first value in the range is for both lists
    #~later~~

    $t->{'available'} = \@avail;
    $t->{'success'} = 0;

    #Is what got generated a desired result?
    if (i_elementof_J($t->{'generated'},$t->{'available'})) {
        $t->{'success'} += 1;
        return;
    }

    #If I keep my value of 'a', can I get a valid value for 'b'?
    my @rb_reduced = I_reduceby_j($t->{'available'},$opts->{$a}->{"val"});

    @rb_reduced = intersect(\@rb_reduced,\@rb);
    if (scalar @rb_reduced > 0) {
        $opts->{$b}->{'val'} = $rb_reduced[rand scalar @rb_reduced];
        $t->{'success'} += 2;
        return;
    }

    #Let's do the same for a
    my @ra_reduced = I_reduceby_j($t->{'available'},$opts->{$b}->{'val'});
    @ra_reduced = intersect(\@ra_reduced,\@ra);
    if (scalar @ra_reduced > 0) {
        $opts->{$a}->{'val'} = $ra_reduced[rand scalar @ra_reduced];
        $t->{'success'} += 4;
        return;
    }

    #Somehow, no value for a or b has a corresponding valid value for the other setting
    #This means we need to reshuffle, but even that has a chance of failure, if the above is true
    #We already determined that there is a valid set of available sums, so let's iterate through those
    #And then find an A/B pair that fits
    foreach my $forced_sum @{$t->{'available'}} {
        foreach my $m(reverse @ra) {
            my $n = $forced_sum - $m;
            if (i_elementof_J($n,\@rb)) {
                $opts->{$a}->{val} = $m;
                $opts->{$b}->{val} = $n;
                $t->{'success'} += 8;
                return;
            }
        }

        foreach my $n(reverse @rb) {
            my $m = $forced_sum -$n;
            if (i_elementof_J($m,\@ra)) {
                $opts->{$a}->{val} = $m;
                $opts->{$b}->{val} = $n;
                $t->{'success'} += 16;
                return;
            }
        }
    }

    #Getting to this shouldn't be possible, because the list of available options is
    #Defined as the list of sum values that are possible intersected with sum values that are desired
    print "Error processing key pair constraint:" . join("+",$a,$b) . "\n";
    print "Unable to generate a pair of values that satisfy requested sum range that also satisfies individual ranges for $a and $b.\n";
    print "Defined range for $a: ". join(",",@ra) . "\n";
    print "Defined rbnge for $b: ". join(",",@rb) . "\n";
    print "Possible sum range: " . join(",",@possible) . "\n";
    print "Requested sum range: " . join(",",@r) . "\n";
    print "Intersection of possible ^ requested: " . join(",",@avail) "\n";
    print "This kind of error shouldn't be possible but the world is full of surprises\n";
    print "Keeping initially  generated values for $a,$b\n";
}

sub I_reduceby_j {
    my ($r,$j) = @_;
    my @I;
    foreach my $v(@{$r}) {
        push @I, ($v - $j);
    }
    return @I;
}

sub i_elementof_J {
    my ($e,$r) = @_;
    foreach my $i(@{$r}) {
        if ($e == $i) {
            return 1;
        }
    }
    return 0;
}

sub intersect {
    my ($i, $j) = @_;

    my @int;
    foreach my $ii (@{$i}) {
        foreach my $jj (@{$j}) {
            if ($ii == $jj) {
                push @int, $ii;
            }
        }
    }
    return @int;
}
