#!/usr/bin/perl
use strict;
use warnings;
use SetupOpenTTD::Shortcuts qw(do_cmd do_cmd_topline contains);
use MIME::Base64;
use Data::Dumper;
use Getopt::Long;
use List::Util qw(uniq);

my @protected = qw(version_string version_number ini_version);
my $meta_key = 'shuffler^constraints';
my ($k_value,$k_sum,$k_range,$k_keypair,$k_wanted,$k_possible,$k_available) = qw(value sum range keypair want possible available);
my $debug;

#Hashref containing data structure of the form
# keyN => ('val' => x, 'range' => (a..b)), where
#  keyN is some option from the config,
#  the range is the user-defined range,
#  and x is the setting randomly selected from that range
#Constraint options will get stored in a subhash 'shuffler^constraints'

my $opts;

my $defaults;
#The config file should be in ~ for the user executing the script

my $home        = $ENV{HOME};
my $opts_file   = "$home/custom_options.cfg";
my $conf_path   = "$home/.config/openttd/";
my $template    = "$conf_path/openttd.cfg.orig";
my $target_file = "$conf_path/openttd.cfg";

GetOptions (
    "s|settings-file=s"     =>  \$opts_file,
    "t|template-config=s"   =>  \$template,
    "d|defaults!"           =>  \$defaults,
    "f|target-file=s"       =>  \$target_file,
);

#If called with --defaults, don't read the customs file. just print out the contents of the default config
unless ($defaults) {
    open (my $ro, "<", $opts_file) or die "Unable to open settings file '$opts_file'. Can't generate the config:$!\n";
    $opts = process_custom($ro);
    close ($ro);
}

#Process constraint options
foreach my $lim(@{$opts->{$meta_key}}) {
    process_lim($lim);
}


#Read a base config file, hopefully generated by openttd
open(my $ro, "<", $template) or die "Failed to load default config file '$template': $!\n";

my $conf = generate_conf($ro,$opts);
close($ro);


#Spew the contents of the generated config into the target file
open(my $fh, ">", $target_file) or die "Failed to create custom settings file '$target_file':$!\n";
print $fh $conf;
close($fh);

#subfunctions
sub process_custom {
    my ($ro) = @_;
    my $dat;
    while (my $line=<$ro>) {
        chomp $line;
        print Dumper "Read line: $line" if $debug;
        next if ($line =~ m/(^$|^#)/);
        my ($opt,$setting,$range,$meta) = scan_line($line);
        if (contains(\@protected, $opt)) {
            next;
        }
        if ($meta) {
            #We'll process the contraints after all the custom options have been generated
            push @{$dat->{$meta_key}}, $meta;
        }
        if (defined $opt && defined $setting) {
            $dat->{$opt}->{$k_value} = $setting;
            print Dumper "name: $opt, setting: $setting, range: " . oneline_list($range) if $debug;
            if (scalar @{$range} > 0) {
                $dat->{$opt}->{$k_range} = $range;
            }
        }
    }
    return $dat;
}

sub generate_conf {
    my ($rc,$cfg) = @_;
    my @out;
    my %meta;

    while (my $line=<$rc>) {
        my ($k,$v,$range,$meta) = scan_line($line);

        #Keep empty lines
        unless (defined $k && $k !~ m/^\s*$/) {
            push @out, " ";
            next;
        }

        #keep section headers
        if ($k =~m/^\[(\S)+\]$/) {
            push @out, $k;
            next
        }

        #keep lines with no option set
        unless (defined $v) {
            push @out, "$k = ";
            next;
        }


        #If a custom option was configured, override the default
        if (exists $cfg->{$k} && defined $cfg->{$k}) {
            $v = $cfg->{$k}->{$k_value};
        }

        $line = "$k = $v";
        push @out, $line;
    }
    my $data = join("\n",@out);
    return $data;
}

sub scan_line {
    my ($li) = @_;
    my $val;
    my $range;
    my $meta;

    if ($li =~ m/(^#|^$)/) {
        return ($li);
    }
    chomp $li;
    if ($li =~ m/;/) {
        my @parts = split(/;/, $li);
        $li = shift @parts;
    }
    my @kv = split(/\s*=\s*/, $li);


    my $k = shift @kv;

    #AI lines look like `none = start_date=730` and are not yet supported for randomization settings
    if (scalar @kv > 1) {
        $val = process_ai(@kv);
        return ($k,$val);
    }

    my $v = shift @kv;
    unless (defined $v) {
        #$k has no option set, $v and $range are both undefined
        return ($k);
    }
    print Dumper "Processing configured setting '$v'" if $debug;
    #if it gets to this point, we actually are trying to configure an option. possibly randomized, or a static setting
    if ($v =~ m/^\s*<\s*(\S+)\s*>\s*$/) {
        my $rand = $1;
        print Dumper "Looks like someone wants some randomness $rand" if $debug;
        #randomly set option, range should be list of all possible values
        ($val,$range) = process_random($rand);
        print Dumper "Got value $val and range: " . oneline_list($range) if $debug;
    } else {
        #statically defined option, define it's range as ($v);
        $val = $v;
        push @$range, $v;
        print Dumper "Value is statically set to $v, so range is: " . oneline_list($range) if $debug;
    }

    #handle multi-option constraint lines: <shuffler.$option1+$option2> = <a..b>
    # the generated values for opt1,opt2, as well as their respective ranges, are required for validation,
    # but there's no gaurantee that those have been set yet in the custom options file.
    # So, those will have to wait until the options file is fully processed
    if ($k =~ m/^\s*<\s*shuffler\.\s*(\S+)\s*\+\s*(\S+)\s*>\s*$/i) {
        my ($opt1,$opt2) = sort ($1,$2);
        @{$meta->{$k_keypair}} = ($opt1,$opt2);
        $meta->{$k_wanted} = $range;
    }
    print Dumper "is range still set?" . oneline_list($range) if $debug;

    if (!defined $meta) {
        $meta = 0;
    }

    return ($k,$val,$range,$meta);
}

sub process_ai {
    #I'm not entirely sure how to set these yet
    my @parts = @_;
    my $v = join("=",@parts);
    return $v;
}

sub process_random {
    my ($l) = @_;
    my @arr;

    print Dumper "working on line $l" if $debug;
    #handle booleans
    if ($l =~ m/^bool(ean)?$/i) {
        print Dumper "looks like a boolean opt" if $debug;
        $l = "true,false";
    }

    #evaluate number range
    if ($l =~ m/([0-9]+)\.\.([0-9]+)/) {
        print Dumper "looks like an int range" if $debug;
        @arr = ($1 .. $2);
    }

    #evaluate lists
    if ($l =~ m/^[a-zA-Z0-9,]+$/) {
        print Dumper "looks like a descrete list" if $debug;
        @arr = split(/,/, $l);
    }

    print Dumper "my range is: "  . oneline_list(\@arr) if $debug;

    return ($arr[int rand (@arr)], \@arr);
}

sub process_lim {
    my ($h) = @_;
    print Dumper "oh boy oh boy!" if $debug;
    my ($a,$b) = @{$h->{$k_keypair}};
    my @r = @{$h->{$k_wanted}};
    print Dumper "$k_wanted: " . oneline_list(\@r) if $debug;

    #First get the ranges allowed from the config
    my @ra = @{$opts->{$a}->{$k_range}};
    my @rb = @{$opts->{$b}->{$k_range}};
    print Dumper "$a: " . oneline_list(\@ra) if $debug;
    print Dumper "$b: " . oneline_list(\@rb) if $debug;

    #Force them both to be defined
    #~later~~

    my @possible;
    foreach my $i (@ra) {
        foreach my $j (@rb) {
            push @possible, $i+$j;
        }
    }
    @possible = uniq @possible;
    print Dumper "all possible sums: " . oneline_list(\@possible) if $debug;

    $h->{$k_possible} = \@possible;
    $h->{$k_sum} = $opts->{$a}->{$k_value} + $opts->{$b}->{$k_value};
    print Dumper "got sum: $h->{$k_sum}" if $debug;

    #Find the intersection of the two
    #considered forcing one to be a subset of the other but it was a pain to decide which should be the superset

    my @avail = intersect($h->{$k_wanted},$h->{$k_possible});
    print Dumper "got intersection: " . oneline_list(\@avail) if $debug;

    #If this is an empty list, force both values to be whatever the first value in the range is for both lists
    #~later~~

    $h->{$k_available} = \@avail;
    #$succss = 0;

    #Is what got generated a desired result?
    if (i_elementof_J($h->{$k_sum},$h->{$k_available})) {
        #$succss += 1;
        return;
    }

    #If I keep my value of 'a', can I get a valid value for 'b'?
    my @rb_reduced = I_reduceby_j($h->{$k_available},$opts->{$a}->{$k_value});

    @rb_reduced = intersect(\@rb_reduced,\@rb);
    if (scalar @rb_reduced > 0) {
        $opts->{$b}->{$k_value} = $rb_reduced[rand scalar @rb_reduced];
        #$succss += 2;
        return;
    }

    #Let's do the same for a
    my @ra_reduced = I_reduceby_j($h->{$k_available},$opts->{$b}->{$k_value});
    @ra_reduced = intersect(\@ra_reduced,\@ra);
    if (scalar @ra_reduced > 0) {
        $opts->{$a}->{$k_value} = $ra_reduced[rand scalar @ra_reduced];
        #$succss += 4;
        return;
    }

    #Somehow, no value for a or b has a corresponding valid value for the other setting
    #This means we need to reshuffle, but even that has a chance of failure, if the above is true
    #We already determined that there is a valid set of available sums, so let's iterate through those
    #And then find an A/B pair that fits
    foreach my $forced_sum (@{$h->{$k_available}}) {
        foreach my $m(reverse @ra) {
            my $n = $forced_sum - $m;
            if (i_elementof_J($n,\@rb)) {
                $opts->{$a}->{$k_value} = $m;
                $opts->{$b}->{$k_value} = $n;
                #$succss += 8;
                return;
            }
        }

        foreach my $n(reverse @rb) {
            my $m = $forced_sum -$n;
            if (i_elementof_J($m,\@ra)) {
                $opts->{$a}->{$k_value} = $m;
                $opts->{$b}->{$k_value} = $n;
                #$succss += 16;
                return;
            }
        }
    }

    #Getting to this shouldn't be possible, because the list of available options is
    #Defined as the list of sum values that are possible intersected with sum values that are desired
    print "Error processing key pair constraint:" . join("+",$a,$b) . "\n";
    print "Unable to generate a pair of values that satisfy requested sum range that also satisfies individual ranges for $a and $b.\n";
    print "Defined range for $a: ". oneline_list(\@ra) . "\n";
    print "Defined rbnge for $b: ". oneline_list(\@rb) . "\n";
    print "Possible sum range: " . oneline_list(\@possible) . "\n";
    print "Requested sum range: " . oneline_list(\@r) . "\n";
    print "Intersection of possible ^ requested: " . oneline_list(\@avail) . "\n";
    print "This kind of error shouldn't be possible but the world is full of surprises\n";
    print "Keeping initially generated values for $a,$b\n";
    exit 1;
}

sub I_reduceby_j {
    my ($r,$j) = @_;
    my @I;
    foreach my $v(@{$r}) {
        push @I, ($v - $j);
    }
    return @I;
}

sub i_elementof_J {
    my ($e,$r) = @_;
    foreach my $i(@{$r}) {
        if ($e == $i) {
            return 1;
        }
    }
    return 0;
}

sub intersect {
    my ($i, $j) = @_;
    print Dumper $i if $debug;
    print Dumper $j if $debug;

    my @int;
    foreach my $ii (@{$i}) {
        foreach my $jj (@{$j}) {
            if ($ii == $jj) {
                push @int, $ii;
            }
        }
    }
    return @int;
}
sub oneline_list {
    my ($l) = @_;
    return join(",",@{$l});
}
